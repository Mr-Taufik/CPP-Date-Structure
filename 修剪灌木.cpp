#include <iostream>
#include <algorithm>
using namespace std;

int main() {
     int N;
     cin >> N;

     // 对于每棵灌木（从1到N），依题目逻辑计算其最高高度
     for (int i = 1; i <= N; i++)
     {
          int height;
          if (i == 1 || i == N)
          {
               // 最左侧和最右侧的灌木，每次修剪间隔为 2*(N-1) 天
               height = 2 * (N - 1);
          }
          else
          {
               // 中间的灌木两次修剪之间分别为 2*(i-1) 和 2*(N-i) 天，
               // 最高高度为两者中较大值
               height = 2 * max(i - 1, N - i);
          }
          cout << height << endl;
     }

     return 0;
}



判断当前灌木是否是边界（最左侧或最右侧）：

当 i == 1 或 i == N 时，表示当前灌木位于最左侧或最右侧。

对于边界处的灌木，修剪间隔固定为 2 * (N - 1) 天，因此高度也就是 2 * (N - 1)。

处理中间的灌木：

对于中间的灌木（即 i 既不等于 1 也不等于 N），它们的修剪间隔由两部分决定：

左侧间隔：2 * (i - 1) 天

右侧间隔：2 * (N - i) 天

由于灌木在两侧修剪的间隔不同，最终能达到的最高高度取决于更长的那一段间隔。代码中使用 max(i - 1, N - i) 来找出左侧和右侧间隔中较大的那个值，并乘以 2 得到高度。
